# Алгоритмы и структуры данных.

## Урок 1. Вводная лекция. Алгоритмы. Сложность алгоритмов.


* __Алгоритм__  — это точно определённая инструкция,
последовательно применяя которую к исходным данным, можно получить решение задачи.

Часто алгоритм можно представить в виде блок-схемы.
Например - алгоритм вычисления, является ли введенное
число четным.

### Program_01.java 
* Алгоритм поиска допустимых делителей.

Линейная зависимость характеризуется симметричным
ростом количества шагов относительно увеличения
объема входных данных.

* Алгоритм поиска простых чисел.

Квадратичная зависимость характеризуется резким ростом
сложности относительно роста размера входных данных.

## Как описывается сложность алгоритма?

Для описания сложности существует общепринятая нотация  
        __О(f(n)),__ 
где n - размер входных данных.

---------------------------------------------------------------
Например, алгоритм перебора массива циклом for
имеет сложность O(n). С ростом n на x, количество
шагов алгоритма тоже вырастает на x.

for (int i = 0; i < n; i++){
    // do something
}

А использование вложенного цикл for уже будет
имеет сложность O(n^2), например, при n = 3 цикл
сделает 9 итераций, а при n = 4 уже 16 и т.д.


for (int i = 0; i < n; i++){
    for (int j = 0; j < n; j++){
        // do something
    }
}
---------------------------------------------------------------
* Экспоненциальная зависимость.

Яркий пример - задача поиска шанса выпадения определенной суммы на игральный костях.

__Функция вычисления чисел Фибоначчи:__
Последовательность чисел Фибоначчи начинается с чисел 0 и 1, а все последующие элементы
вычисляется путем сложения двух предыдущих. 0, 1, 1, 2, 3, 5, 8, 13, 21,34 и т.д.


## Правила объединения сложности.

* Вызов нескольких методов на каждом шаге: 
        O(2n) == O(n)

Обход половины размерности массива:
        O(n/2) == O(n)
Цифровые множители сокращаются.

* Вызов нескольких методов вне цикла:
        O(2+n) == O(n). 
Цифровые слагаемые сокращаются

method1() - имеет сложность O(n^3)
method2() - имеет сложность O(n^2)

 - Если внутри method1() будет вызываться method2(),
то их сложности перемножаются:
        O(n^3) * O(n^2) == O(n^5)

 - Если методы будут вызываться последовательно, то
их сложности складываются, т.е. берется максимальная из них:
        O(n^3) + O(n^2) == O(n^3)

## Какая бывает сложность алгоритмов?

    ● O(1) - константная. 
Не зависит от объема данных.
Например - поиск по хэш-таблице.

    ● O(log n) - логарифмическая. 
Увеличение размер почти не сказывается на количестве итераций.
Например - бинарный поиск, поиск по
сбалансированному дереву.

    ● O(n) - линейная. 
Увеличение сложности эквивалентно увеличению размера. 
Например - поиск по неотсортированному массиву.

    ● O(n * log n) - увеличение размера заметно 
сказывается на сложности. 
Например - быстрая сортировка.

    ● O(n^2) - квадратичная. 
Увеличение размера очень сильно сказывается на сложности. Например - пузырьковая сортировка.

    ● O(2^n) - экспоненциальная. 
С увеличением размера на 1, сложность возрастает вдвое.


